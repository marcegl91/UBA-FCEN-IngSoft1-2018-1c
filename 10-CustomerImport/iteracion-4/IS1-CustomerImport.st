Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:51'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:52'!tearDown	system commit.	system shutdown! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 10:46'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 15:52'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importCustomersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 15:56'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:41'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:42'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:42'!testCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter addressWithoutCustomerErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:21'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system customerIdentifiedAs: idType numbered: idNumber.	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:20'!assertPepeSanchezWasImportedCorrectly	| customer |	customer := self alwaysImportedCustomer. 		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: self alwaysImportedCustomerIdType withNumber: self alwaysImportedCustomerIdNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:10'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomers size equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/3/2016 09:21'!alwaysImportedCustomer	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedCustomerIdType.	anIdentificationNumber := self alwaysImportedCustomerIdNumber.	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'importing' stamp: 'mv 7/1/2018 04:25'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream using: system) import! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Environment methodsFor: 'system creation' stamp: 'MarceloGuzman 7/2/2018 13:27'!createSupplierSystem	self subclassResponsibility ! !!Environment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:49'!createCustomerSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:46'!current		^self allSubclasses 		detect: [ :anEnvironemntClass | anEnvironemntClass isCurrent ]		ifFound: [ :anEnvironmentClass | anEnvironmentClass new ]		ifNone: [ self error: 'No environment detected' ]! !!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:49'!isCurrent	self subclassResponsibility ! !Environment subclass: #DevelpmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!DevelpmentEnvironment methodsFor: 'system creation' stamp: 'MarceloGuzman 6/28/2018 19:58'!createSupplierSystem		^TransientSupplierSystem new! !!DevelpmentEnvironment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:47'!createCustomerSystem		^TransientCustomerSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelpmentEnvironment class	instanceVariableNames: ''!!DevelpmentEnvironment class methodsFor: 'environment selection' stamp: 'HernanWilkinson 11/4/2016 09:47'!isCurrent		^IntegrationEnvironment isCurrent not! !Object subclass: #Importer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Importer methodsFor: 'importing' stamp: 'MarceloGuzman 7/2/2018 15:36'!import	self subclassResponsibility ! !Importer subclass: #CustomerImporter	instanceVariableNames: 'line readStream record newCustomer system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/2/2016 10:52'!signalInvalidCustomerRecord 		self error: self class invalidCustomerRecordErrorDescription ! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 16:01'!signalAddressWithoutCustomerError	self error: self class addressWithoutCustomerErrorDescription.! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 18:01'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 17:54'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!importAddress	| newAddress |	self assertThereIsCustsomerForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newCustomer addAddress: newAddress! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:55'!isAddressRecord	^ record first = 'A'! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:56'!assertThereIsCustsomerForAddress	newCustomer isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !!CustomerImporter methodsFor: 'initialization' stamp: 'HernanWilkinson 11/4/2016 09:26'!initializeOn: aReadStream using: aCustomerSystem	readStream := aReadStream.	system := aCustomerSystem! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:55'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/4/2016 09:33'!importCustomer	self assertValidCustomerRecordSize.	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	system add: newCustomer! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].	! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:55'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 10:55'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/1/2016 17:52'!importRecord		self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].		self signalInvalidRecordType! !!CustomerImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:54'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!CustomerImporter methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/4/2016 09:27'!from: aReadStream using: aCustomerSystem	^ self new initializeOn: aReadStream using: aCustomerSystem! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 18:00'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!IntegrationEnvironment methodsFor: 'system creation' stamp: 'MarceloGuzman 6/28/2018 20:00'!createSupplierSystem		^PersistentSupplierSystem new! !!IntegrationEnvironment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:45'!createCustomerSystem		^PersistentCustomerSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'environment selection' stamp: 'mv 7/2/2018 17:36'!isCurrent		^false! !Object subclass: #Party	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'identification' stamp: 'MarceloGuzman 7/2/2018 14:06'!identificationNumber	^ self subclassResponsibility ! !!Party methodsFor: 'identification' stamp: 'MarceloGuzman 7/2/2018 14:07'!isIdentifiedAs: anIdType numbered: anIdNumber 	^self subclassResponsibility ! !!Party methodsFor: 'identification' stamp: 'MarceloGuzman 7/2/2018 14:06'!identificationType	^ self subclassResponsibility ! !!Party methodsFor: 'identification' stamp: 'MarceloGuzman 7/2/2018 14:06'!identificationType: anIdentificationType 	^self subclassResponsibility ! !!Party methodsFor: 'identification' stamp: 'MarceloGuzman 7/2/2018 14:06'!identificationNumber: anIdentificationNumber 	^self subclassResponsibility ! !Party subclass: #Customer	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 11/4/2016 09:42'!isIdentifiedAs: anIdType numbered: anIdNumber 		^identificationType = anIdType and: [ identificationNumber = anIdNumber  ]! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 10:05'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 09:43'!numberOfAddresses		^addresses size! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 18:03'!addressesIsEmpty		^addresses isEmpty! !Party subclass: #Supplier	instanceVariableNames: 'id fullName identificationType identificationNumber addresses customers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'customers' stamp: 'MarceloGuzman 7/2/2018 16:28'!customers	^ customers! !!Supplier methodsFor: 'customers' stamp: 'MarceloGuzman 7/2/2018 16:28'!customersIsEmpty		^customers isEmpty! !!Supplier methodsFor: 'customers' stamp: 'MarceloGuzman 7/2/2018 16:27'!numberOfCustomers		^customers size! !!Supplier methodsFor: 'customers' stamp: 'MarceloGuzman 7/2/2018 16:29'!customersIdentifiedAs: anIdentificationType withNumber: anIdentificationNumber	^customers select: [ :aClient | aClient isIdentifiedAs: anIdentificationType numbered: anIdentificationNumber ]! !!Supplier methodsFor: 'customers' stamp: 'MarceloGuzman 7/2/2018 16:27'!addCustomer: aCustomer	customers add: aCustomer! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:04'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:04'!fullName: aFullName	fullName := aFullName! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:04'!fullName	^fullName! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:47'!isIdentifiedAs: anIdType numbered: anIdNumber 		^identificationType = anIdType and: [ identificationNumber = anIdNumber  ]! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:40'!identificationType		^identificationType ! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:40'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Supplier methodsFor: 'identification' stamp: 'MarceloGuzman 6/28/2018 20:04'!identificationNumber		^identificationNumber ! !!Supplier methodsFor: 'accessing' stamp: 'MarceloGuzman 7/2/2018 16:27'!initialize	super initialize.	addresses := OrderedCollection new.	customers := OrderedCollection new.! !!Supplier methodsFor: 'addresses' stamp: 'MarceloGuzman 6/28/2018 20:16'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Supplier methodsFor: 'addresses' stamp: 'MarceloGuzman 6/28/2018 20:05'!addresses	^ addresses! !!Supplier methodsFor: 'addresses' stamp: 'MarceloGuzman 6/28/2018 20:05'!numberOfAddresses		^addresses size! !!Supplier methodsFor: 'addresses' stamp: 'MarceloGuzman 6/28/2018 20:05'!addAddress: anAddress 	addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'MarceloGuzman 7/2/2018 16:03'!addressesIsEmpty		^addresses isEmpty! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'supplierSystem customerSystem erpSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:39'!existingCustomerWithoutSupplierTestData		^ ReadStream on: 'EC,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:50'!newCustomerRecordThatAlreadyExistsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Geronimo,Gutierrez,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:40'!newCustomerRecordStartingWithMoreThanOneNCTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'NCN,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:21'!newCustomerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 17:01'!existingCustomerRecordThatDoesntExistTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'EC,D,545677477'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:22'!newCustomerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,22333444,etc'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:22'!existingCustomerRecordWithLessThanThreeFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'EC,D'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:41'!existingCustomerRecordStartingWithMoreThanOneECTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'ECE,D,5456774'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:22'!existingCustomerRecordWithMoreThanThreeFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'EC,D,5456774,etc'! !!SupplierImportTest methodsFor: 'test data - customers' stamp: 'MarceloGuzman 7/2/2018 16:35'!newCustomerWithoutSupplierTestData		^ ReadStream on: 'NC,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'MarceloGuzman 7/2/2018 14:30'!setUp	supplierSystem := Environment current createSupplierSystem.	supplierSystem start.	supplierSystem beginTransaction.		customerSystem := Environment current createCustomerSystem.	customerSystem start.	customerSystem beginTransaction.		erpSystem := ERPSystem withCustomerSystem: customerSystem andSupplierSystem: supplierSystem.! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:29'!testCanNotImportNewCustomerRecordWithMoreThanFiveFields		self		should: [ self importSuppliersFrom: self newCustomerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:40'!testShouldNotImportNewCustomersRecordsStartingWithMoreThanNC	self 		should: [ self importSuppliersFrom: self newCustomerRecordStartingWithMoreThanOneNCTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:13'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importSuppliersFrom: self addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:42'!testShouldNotImportExistingCustomersRecordsStartingWithMoreThanNC	self 		should: [ self importSuppliersFrom: self existingCustomerRecordStartingWithMoreThanOneECTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:02'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importSuppliersFrom: self addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:15'!testShouldNotImportSupplierRecordsStartingWithMoreThanS	self		should: [ self				importSuppliersFrom: self supplierRecordStartingWithMoreThanOneSTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: supplierSystem suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:36'!testCanNotImportNewCustomerWithoutSupplier	self		should: [ self importSuppliersFrom: self newCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerWithoutSupplierErrorDescription.			self assert: supplierSystem suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:04'!testCanNotImportAddressRecordWithMoreThanSixFields		self		should: [ self importSuppliersFrom: self addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 6/28/2018 21:41'!alwaysImportedSupplier	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedSupplierIdType.	anIdentificationNumber := self alwaysImportedSupplierIdNumber.	^ supplierSystem		supplierIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:00'!testCanNotImportSupplierRecordWithMoreThanFourFields	self		should: [ self				importSuppliersFrom: self supplierRecordWithMoreThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidSupplierRecordErrorDescription.			self assert: supplierSystem suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:25'!testCanNotImportNewCustomerRecordWithLessThanFiveFields		self		should: [ self importSuppliersFrom: self newCustomerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:07'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importSuppliersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedSupplier addressesIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 14:23'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream using: customerSystem) import! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 14:24'!validCustomersTestData	^ReadStream on: 'C,Geronimo,Gutierrez,D,5456774A,Rivadavia,4232,Almagro,1212,BsAs'! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:39'!testCanNotImportExistingCustomerWithoutSupplier	self		should: [ self importSuppliersFrom: self existingCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerWithoutSupplierErrorDescription.			self assert: supplierSystem suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 14:24'!testImportSuppliers	self importCustomersFrom: self validCustomersTestData.	self importSuppliersFrom: self validTestData.	self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WasImportedCorrectly.! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 15:59'!testCanNotImportSupplierRecordWithLessThanFourFields	self		should: [ self				importSuppliersFrom: self supplierRecordWithLessThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter invalidSupplierRecordErrorDescription.			self assert: supplierSystem suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:29'!testCanNotImportExistingCustomerRecordWithMoreThanThreeFields		self		should: [ self importSuppliersFrom: self existingCustomerRecordWithMoreThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:06'!testCanNotImportAddressWithoutSupplier	self		should: [ self importSuppliersFrom: self addressWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter addressWithoutSupplierErrorDescription.			self assert: supplierSystem suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 6/28/2018 21:41'!importSuppliersFrom: inputStream	(SupplierImporter from: inputStream using: supplierSystem) import! !!SupplierImportTest methodsFor: 'testing' stamp: 'MarceloGuzman 7/2/2018 16:30'!testCanNotImportExistingCustomerRecordWithLessThanThreeFields		self		should: [ self importSuppliersFrom: self existingCustomerRecordWithLessThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: SupplierImporter invalidCustomerRecordErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'MarceloGuzman 7/2/2018 16:14'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedSupplierRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'MarceloGuzman 7/2/2018 16:06'!addressWithoutSupplierTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'MarceloGuzman 7/2/2018 16:04'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAs,etc'! !!SupplierImportTest methodsFor: 'test data - address' stamp: 'MarceloGuzman 7/2/2018 16:03'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636'! !!SupplierImportTest methodsFor: 'test data' stamp: 'MarceloGuzman 6/28/2018 20:25'!validTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'test data' stamp: 'MarceloGuzman 7/2/2018 16:08'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'MarceloGuzman 6/28/2018 20:40'!alwaysImportedSupplierRecord	^ 'S,Supplier1,', self alwaysImportedSupplierIdType, ',', self alwaysImportedSupplierIdNumber ! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'MarceloGuzman 7/2/2018 15:59'!supplierRecordWithLessThanFourFieldsTestData		^ ReadStream on: 'S,Supplier1,D'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'MarceloGuzman 7/2/2018 16:16'!supplierRecordStartingWithMoreThanOneSTestData		^ ReadStream on:'SS,Supplier1,D,123'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'MarceloGuzman 6/28/2018 19:50'!alwaysImportedSupplierIdNumber	^ '123'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'MarceloGuzman 6/28/2018 19:50'!alwaysImportedSupplierIdType	^ 'D'! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'MarceloGuzman 7/2/2018 16:00'!supplierRecordWithMoreThanFourFieldsTestData		^ ReadStream on: 'S,Supplier1,D,123,etc'! !!SupplierImportTest methodsFor: 'tests' stamp: 'MarceloGuzman 7/2/2018 16:55'!testShouldNotImportNewCustomerRecordsThatAlreadyExists	self		should: [ self importCustomersFrom: self validCustomersTestData.				self importSuppliersFrom: self newCustomerRecordThatAlreadyExistsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerAlreadyRecordedErrorDescription. ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'MarceloGuzman 7/2/2018 17:00'!testShouldNotImportExistingCustomerRecordsThatDoesntExist	self		should: [ self importSuppliersFrom: self existingCustomerRecordThatDoesntExistTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter customerDoesntExistErrorDescription. ]! !!SupplierImportTest methodsFor: 'asserting' stamp: 'MarceloGuzman 6/28/2018 21:41'!assertImportedSuppliersSizeIsCorrect	self assert: supplierSystem allSuppliers size equals: 1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'MarceloGuzman 6/28/2018 20:13'!assert: supplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := supplier addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'MarceloGuzman 6/28/2018 20:11'!assert: supplier isNamed: fullName identfiedAs: idType withNumber: idNumber numberOfAddresses: addressesSize andNumberOfCustomers: customersSize	self assert: supplier fullName equals: fullName.	self assert: supplier identificationType equals: idType.	self assert: supplier identificationNumber equals: idNumber.	self assert: supplier numberOfAddresses equals: addressesSize .	self assert: supplier numberOfCustomers equals: customersSize .! !!SupplierImportTest methodsFor: 'asserting' stamp: 'MarceloGuzman 7/2/2018 16:29'!assertSupplier1WasImportedCorrectly	| supplier |	supplier := self alwaysImportedSupplier. 		self assert: supplier isNamed: 'Supplier1' identfiedAs: self alwaysImportedSupplierIdType withNumber: self alwaysImportedSupplierIdNumber numberOfAddresses: 2 andNumberOfCustomers: 2.		self assert: (supplier customersIdentifiedAs: 'D' withNumber: '22333444') size equals: 1.	self assert: (supplier customersIdentifiedAs: 'D' withNumber: '5456774') size equals: 1.		self assert: supplier hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: supplier hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !Importer subclass: #SupplierImporter	instanceVariableNames: 'readStream system line record newSupplier'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MarceloGuzman 7/2/2018 16:38'!importAddress	| newAddress |	self assertThereIsSupplierForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ newSupplier addAddress: newAddress! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MarceloGuzman 7/2/2018 16:36'!assertThereIsSupplier	newSupplier isNil ifTrue: [ self signalAddressWithoutSupplierError ].! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MarceloGuzman 7/2/2018 16:38'!assertThereIsSupplierForCustomer	newSupplier isNil ifTrue: [ self signalCustomerWithoutSupplierError ].! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MarceloGuzman 6/28/2018 20:51'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MarceloGuzman 6/28/2018 20:50'!isAddressRecord	^ record first = 'A'! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'MarceloGuzman 7/2/2018 16:37'!assertThereIsSupplierForAddress	newSupplier isNil ifTrue: [ self signalAddressWithoutSupplierError ].! !!SupplierImporter methodsFor: 'importing' stamp: 'MarceloGuzman 6/28/2018 20:30'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MarceloGuzman 6/28/2018 20:31'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MarceloGuzman 7/2/2018 14:55'!importRecord		self isSupplierRecord ifTrue: [ ^self importSupplier ].	self isAddressRecord ifTrue: [ ^self importAddress ].	self isNewCustomerRecord ifTrue: [ ^self importNewCustomer ].	self isExistingCustomerRecord ifTrue: [ ^self importExistingCustomer ].		self signalInvalidRecordType! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MarceloGuzman 6/28/2018 20:30'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!SupplierImporter methodsFor: 'importing - private' stamp: 'mv 7/2/2018 07:16'!associatedCustomerSystem	^ system erpSystem customerSystem! !!SupplierImporter methodsFor: 'importing - private' stamp: 'MarceloGuzman 6/28/2018 20:31'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 7/2/2018 17:00'!signalCustomerDoesntExist	self error: self class customerDoesntExistErrorDescription! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 6/28/2018 20:50'!signalAddressWithoutSupplierError	self error: self class addressWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 6/28/2018 20:51'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 6/28/2018 20:37'!signalInvalidSupplierRecord 		self error: self class invalidSupplierRecordErrorDescription ! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 7/2/2018 15:23'!signalInvalidCustomerRecord		self error: self class invalidCustomerRecordErrorDescription ! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 7/2/2018 16:38'!signalCustomerWithoutSupplierError	self error: self class customerWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 6/28/2018 20:31'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!SupplierImporter methodsFor: 'error signal' stamp: 'MarceloGuzman 7/2/2018 15:33'!signalCustomerAlreadyRecorded		self error: self class customerAlreadyRecordedErrorDescription ! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'MarceloGuzman 6/28/2018 20:37'!assertValidSupplierRecordSize		record size ~= 4 ifTrue: [ self signalInvalidSupplierRecord ].! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'MarceloGuzman 6/28/2018 20:36'!importSupplier	self assertValidSupplierRecordSize.		newSupplier := Supplier new.	newSupplier fullName: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.	system add: newSupplier! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'MarceloGuzman 6/28/2018 20:32'!isSupplierRecord	^ record first = 'S'! !!SupplierImporter methodsFor: 'initialization' stamp: 'MarceloGuzman 6/28/2018 20:29'!initializeOn: aReadStream using: aSupplierSystem	readStream := aReadStream.	system := aSupplierSystem! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 7/2/2018 16:24'!assertValidNewCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].	! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 7/2/2018 16:59'!assertExistingCustomerAlreadyExistWith: identificationType numbered: identificationNumber.	(self associatedCustomerSystem allCustomers anySatisfy: [ :customer | customer identificationType  = identificationType and:[customer identificationNumber  = identificationNumber ] ])	ifFalse: [self error: self signalCustomerDoesntExist ].			! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 7/2/2018 16:24'!assertValidExistingCustomerRecordSize		record size ~= 3 ifTrue: [ self signalInvalidCustomerRecord ].	! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 7/2/2018 15:38'!assertCustomerDoesntExist: aNewCustomer		(self associatedCustomerSystem allCustomers anySatisfy: [ :customer | customer identificationType  = aNewCustomer identificationType and: [customer identificationNumber  = aNewCustomer identificationNumber] ]) ifTrue: [ self signalCustomerAlreadyRecorded ]			! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 6/28/2018 20:33'!isNewCustomerRecord	^ record first = 'NC'! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 7/2/2018 16:57'!importExistingCustomer	|identificationType identificationNumber|		self assertThereIsSupplierForCustomer.	self assertValidExistingCustomerRecordSize.		identificationType := record second.	identificationNumber := record third.		self assertExistingCustomerAlreadyExistWith: identificationType numbered: identificationNumber.		newSupplier addCustomer: (self associatedCustomerSystem customerIdentifiedAs: identificationType numbered: identificationNumber).! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 6/28/2018 20:33'!isExistingCustomerRecord	^ record first = 'EC'! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'MarceloGuzman 7/2/2018 16:38'!importNewCustomer	|newCustomer|		self assertThereIsSupplierForCustomer.	self assertValidNewCustomerRecordSize.		newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.		self assertCustomerDoesntExist: newCustomer.		self associatedCustomerSystem add: newCustomer.		newSupplier addCustomer: newCustomer.			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'MarceloGuzman 6/28/2018 20:29'!from: aReadStream using: aSupplierSystem	^ self new initializeOn: aReadStream using: aSupplierSystem! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 7/2/2018 15:24'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 7/2/2018 16:08'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 6/28/2018 20:51'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 6/28/2018 20:50'!addressWithoutSupplierErrorDescription		^'There is no Supplier for the imported address'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 7/2/2018 16:36'!customerWithoutSupplierErrorDescription		^'There is no Supplier for the imported customer'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 6/28/2018 20:38'!invalidSupplierRecordErrorDescription		^'Invalid supplier record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 7/2/2018 17:00'!customerDoesntExistErrorDescription		^'Customer doesnt exist'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'MarceloGuzman 7/2/2018 15:33'!customerAlreadyRecordedErrorDescription		^'Customer already recorded'! !Object subclass: #System	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!System methodsFor: 'initialization' stamp: 'mv 7/2/2018 18:18'!setERPSystem: anERPSystem.	self subclassResponsibility! !!System methodsFor: 'initialization' stamp: 'mv 7/2/2018 18:19'!erpSystem	self subclassResponsibility! !System subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!beginTransaction	self subclassResponsibility! !!CustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!commit	self subclassResponsibility! !!CustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self subclassResponsibility! !!CustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!add: aCustomer	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customersIsEmpty	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!allCustomers	self subclassResponsibility! !!CustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	self subclassResponsibility! !!CustomerSystem methodsFor: 'erp system' stamp: 'MarceloGuzman 6/28/2018 21:20'!setERPSystem: anERPSystem.	self subclassResponsibility! !!CustomerSystem methodsFor: 'erp system' stamp: 'mv 7/2/2018 18:18'!erpSystem	self subclassResponsibility! !System subclass: #ERPSystem	instanceVariableNames: 'customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ERPSystem methodsFor: 'initialization' stamp: 'MarceloGuzman 7/2/2018 14:29'!initializeWithCustomerSystem: aCustomerSystem andSupplierSystem: aSupplierSystem.	customerSystem := aCustomerSystem.	customerSystem setERPSystem: self.		supplierSystem := aSupplierSystem.	supplierSystem setERPSystem: self.! !!ERPSystem methodsFor: 'system' stamp: 'MarceloGuzman 7/2/2018 14:37'!supplierSystem	^supplierSystem! !!ERPSystem methodsFor: 'system' stamp: 'MarceloGuzman 6/28/2018 21:35'!customerSystem	^customerSystem	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ERPSystem class	instanceVariableNames: ''!!ERPSystem class methodsFor: 'instance creation' stamp: 'MarceloGuzman 7/2/2018 14:28'!withCustomerSystem: aCustomerSystem andSupplierSystem: aSupplierSystem	^self new initializeWithCustomerSystem: aCustomerSystem andSupplierSystem: aSupplierSystem.! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session erpSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!beginTransaction	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!commit	session commit! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/3/2016 08:54'!initialize		super initialize.	self initializeSession. ! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'MarceloGuzman 6/28/2018 21:38'!setERPSystem: anERPSystem.	erpSystem := anERPSystem.! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/4/2016 09:19'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping)! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'mv 7/1/2018 04:08'!erpSystem		^erpSystem! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:52'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll: self addressMappingArray! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:51'!customerMappingArray	^ Array		with: (EmbededMapping withDefaultFieldNameFor: #firstName)		with: (EmbededMapping withDefaultFieldNameFor: #lastName)		with: (EmbededMapping withDefaultFieldNameFor: #identificationType)		with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)		with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:51'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll: self customerMappingArray! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:52'!addressMappingArray	^ Array		with: (EmbededMapping withDefaultFieldNameFor: #streetName)		with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)		with: (EmbededMapping withDefaultFieldNameFor: #town)		with: (EmbededMapping withDefaultFieldNameFor: #zipCode)		with: (EmbededMapping withDefaultFieldNameFor: #province)! !!PersistentCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	session start! !!PersistentCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	session shutdown! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:33'!add: aCustomer	session persist: aCustomer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'mv 7/2/2018 18:39'!searchCustomerWith: anIdentifycationType and: anIdentificationNumber	^ session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/3/2016 09:11'!customersIsEmpty	^ self allCustomers isEmpty! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:18'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'mv 7/2/2018 18:49'!assertCustomerSearchHasOneResult: customers	customers size = 1		ifFalse:			[ self error: self class noOrMoreThanOneCustomerFoundErrorDescription ]! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'mv 7/2/2018 18:49'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| customers |	customers := self		searchCustomerWith: anIdentifycationType		and: anIdentificationNumber.	self assertCustomerSearchHasOneResult: customers.	^ customers anyOne! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentCustomerSystem class	instanceVariableNames: ''!!PersistentCustomerSystem class methodsFor: 'as yet unclassified' stamp: 'mv 7/2/2018 18:47'!noOrMoreThanOneCustomerFoundErrorDescription		^'No or more that one customer found' ! !System subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierSystem methodsFor: 'erp system' stamp: 'MarceloGuzman 6/28/2018 21:20'!setERPSystem: anERPSystem.	self subclassResponsibility! !!SupplierSystem methodsFor: 'erp system' stamp: 'mv 7/2/2018 18:18'!erpSystem	self subclassResponsibility! !!SupplierSystem methodsFor: 'transaction' stamp: 'mv 7/2/2018 18:21'!beginTransaction	self subclassResponsibility! !!SupplierSystem methodsFor: 'system live cycle' stamp: 'mv 7/2/2018 18:21'!start	self subclassResponsibility! !!SupplierSystem methodsFor: 'system live cycle' stamp: 'mv 7/2/2018 18:21'!shutdown	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:53'!add: aSupplier	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 18:21'!commit	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:53'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:53'!suppliersIsEmpty	self subclassResponsibility! !!SupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:53'!allSuppliers	self subclassResponsibility! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'erpSystem session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:24'!add: aSupplier	session persist: aSupplier! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 18:50'!assertSupplierSearchHasOneResult: suppliers	suppliers size = 1		ifFalse:			[ self error: self class noOrMoreThanOneSupplierFoundErrorDescription ]! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 18:50'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| suppliers |	suppliers := self		searchSupplierWith: anIdentifycationType		and: anIdentificationNumber.	self assertSupplierSearchHasOneResult: suppliers.	^ suppliers anyOne! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:27'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 07:36'!suppliersIsEmpty	^ self allSuppliers isEmpty! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'mv 7/2/2018 18:38'!searchSupplierWith: anIdentifycationType and: anIdentificationNumber	^ session		select: [ :aSupplier | 			aSupplier identificationType = anIdentifycationType				and: [ aSupplier identificationNumber = anIdentificationNumber ] ]		ofType: Supplier! !!PersistentSupplierSystem methodsFor: 'transaction' stamp: 'mv 7/2/2018 07:23'!beginTransaction	session beginTransaction! !!PersistentSupplierSystem methodsFor: 'transaction' stamp: 'mv 7/2/2018 07:23'!commit	session commit! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'mv 7/2/2018 07:41'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping)! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'mv 7/2/2018 07:22'!initialize		super initialize.	self initializeSession. ! !!PersistentSupplierSystem methodsFor: 'system live cycle' stamp: 'mv 7/2/2018 07:20'!start	session start! !!PersistentSupplierSystem methodsFor: 'system live cycle' stamp: 'mv 7/2/2018 07:20'!shutdown	session shutdown! !!PersistentSupplierSystem methodsFor: 'erp system' stamp: 'mv 7/2/2018 07:20'!setERPSystem: anERPSystem.	erpSystem := anERPSystem.! !!PersistentSupplierSystem methodsFor: 'erp system' stamp: 'mv 7/2/2018 07:22'!erpSystem		^erpSystem! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:52'!customerMappingArray	^ Array		with: (EmbededMapping withDefaultFieldNameFor: #firstName)		with: (EmbededMapping withDefaultFieldNameFor: #lastName)		with: (EmbededMapping withDefaultFieldNameFor: #identificationType)		with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)		with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:52'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll: self customerMappingArray! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:53'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll: self supplierMappingArray! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:52'!addressMappingArray	^ Array		with: (EmbededMapping withDefaultFieldNameFor: #streetName)		with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)		with: (EmbededMapping withDefaultFieldNameFor: #town)		with: (EmbededMapping withDefaultFieldNameFor: #zipCode)		with: (EmbededMapping withDefaultFieldNameFor: #province)! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:53'!supplierMappingArray	^ Array		with: (EmbededMapping withDefaultFieldNameFor: #fullName)		with: (EmbededMapping withDefaultFieldNameFor: #identificationType)		with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)		with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)! !!PersistentSupplierSystem methodsFor: 'mapping' stamp: 'mv 7/2/2018 18:52'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll: self addressMappingArray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentSupplierSystem class	instanceVariableNames: ''!!PersistentSupplierSystem class methodsFor: 'as yet unclassified' stamp: 'mv 7/2/2018 17:56'!noOrMoreThanOneSupplierFoundErrorDescription		^'No or more that one supplier found' ! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers erpSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!beginTransaction		! !!TransientCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!commit		! !!TransientCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	! !!TransientCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown		! !!TransientCustomerSystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/4/2016 09:41'!initialize		customers := OrderedCollection new! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:39'!add: aCustomer	customers add: aCustomer! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:40'!customersIsEmpty	^ customers isEmpty ! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:39'!allCustomers	^ customers copy! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:40'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'MarceloGuzman 6/28/2018 21:37'!setERPSystem: anERPSystem.	erpSystem := anERPSystem.! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'mv 7/1/2018 04:08'!erpSystem		^erpSystem! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers erpSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientSupplierSystem methodsFor: 'system live cycle' stamp: 'MarceloGuzman 6/28/2018 20:24'!start! !!TransientSupplierSystem methodsFor: 'system live cycle' stamp: 'MarceloGuzman 6/28/2018 20:43'!shutdown! !!TransientSupplierSystem methodsFor: 'transaction' stamp: 'MarceloGuzman 6/28/2018 20:24'!beginTransaction! !!TransientSupplierSystem methodsFor: 'transaction' stamp: 'MarceloGuzman 6/28/2018 20:42'!commit! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MarceloGuzman 6/28/2018 20:42'!allSuppliers	^ suppliers copy! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MarceloGuzman 6/28/2018 20:42'!suppliersIsEmpty	^ suppliers isEmpty ! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MarceloGuzman 6/28/2018 20:43'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^suppliers detect: [ :aSupplier | aSupplier isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'MarceloGuzman 6/28/2018 20:42'!add: aSupplier	suppliers add: aSupplier! !!TransientSupplierSystem methodsFor: 'initialization' stamp: 'MarceloGuzman 6/28/2018 20:43'!initialize		suppliers := OrderedCollection new! !!TransientSupplierSystem methodsFor: 'erp system' stamp: 'MarceloGuzman 6/28/2018 21:22'!setERPSystem: anERPSystem.	erpSystem := anERPSystem.! !!TransientSupplierSystem methodsFor: 'erp system' stamp: 'mv 7/1/2018 04:04'!erpSystem		^erpSystem! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 2 July 2018 at 6:53:51.217105 pm'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 2 July 2018 at 6:53:51.220338 pm'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !